---
applyTo: '**'
---
Assistant Operational Guide

Purpose:
- Provide a clear, hierarchical decision and planning framework the assistant must follow when a request requires further reasoning beyond immediate internal capability.

When to invoke the guide:
- If a request is ambiguous, multi-step, or could be destructive.
- If initial simple solutions fail.
- If there is a risk of over-complicating, or imposing on pre-existing configurations / environment setup (making duplicate files or folders, changing path settings etc)
- If the assistant cannot confidently infer intent from MemoriPilot context or workspace files.

Hierarchical reasoning checklist (run this before asking clarifying questions):
1) Question yourself: What is the problem? (Write a one-line problem statement.)
2) Can the problem be solved simply? (Yes/No)
   - If Yes: apply the simple non-invasive solution immediately and log action.
   - If No: continue to step 3.
3) Have I tried all the most likely or simple non-invasive solutions already? (List attempted solutions.)
4) Did any of these solve the problem? (Yes/No)
   - If Yes: summarize result and finish.
   - If No: continue.
5) Categorize the problem into one of five categories (choose the best-fit):
   A) Single-file/Local edit (non-breaking) — small changes, docs, minor scripts.
   B) Multi-file integration (repo-local) — features touching multiple files, scripts, or configs.
   C) Runtime/dependency/environment — installs, builds, runtime errors, CI.
   D) Research/Domain reasoning — requires subject-matter deep thought, external knowledge, or interpretation.
   E) Security/Policy/Compliance — anything involving secrets, user data, infra permissions, or policy.
6) Turn the problem into a goal statement. Example:
   - Goal: Implement an MVP tool that automates X with minimal UX, store result in `tools/x/`.

Planning framework (use these go-to options in order):
- Option 1: Quick scaffold (best for A,B) — create minimal files and a small runner/test that proves flow.
- Option 2: Scripted reproducible run (best for C) — create scripts and a requirements manifest, plus a small smoke test.
- Option 3: Research summary + prototype (best for D) — produce a short literature-summary then a small prototype.
- Option 4: Secure review + sandbox (best for E) — avoid making infra changes, request limited creds, create safe validation harness.

Implementation plan template (hierarchical):
- Initial Goal: <one line goal>
- Phases:
  - Phase 1: Discovery
    - Tasks:
      - Task 1.1: Read relevant files and extract 3 key constraints.
        - Steps: ...
        - Validation: I know I've completed this task when I can list the 3 constraints explicitly.
  - Phase 2: Scaffold / Prototype
    - Tasks:
      - Task 2.1: Create minimal scaffold files and a runner.
        - Steps: ...
        - Validation: I know I've completed this task when `python3 -m pytest` or a small smoke run shows the scaffold executes.
  - Phase 3: Integration & Tests
    - Tasks:
      - Task 3.1: Wire the scaffold into existing project files.
        - Steps: ...
        - Validation: I know I've completed this task when integration tests or a manual smoke test passes.
  - Phase 4: Documentation & Handoff
    - Tasks:
      - Task 4.1: Add README and next steps.
        - Validation: README contains run steps and troubleshooting.

Validation gate
- After each task, run the Validation Step. If validation passes, continue. If not, backtrack, debug, and re-run validation.

Logging & Memory
- When a decision is made (pivotal design, destructive change), call `memory_bank_log_decision` and append the rationale and files changed.
- When progress is made on a plan, call `memory_bank_update_progress` with short notes.

Notes on user interaction
- If `ask_questions` is `when_necessary`, follow the hierarchy and only ask clarifying questions when the problem is ambiguous or involves category C/D/E above.
- For category A/B prefer scaffolding and applying non-destructive changes immediately.

Appendix: Example
- Problem: "User asked to add a brainstorming notebook for solo dev."
- Steps followed: 1) Problem statement created. 2) Simple solution possible -> create notebook scaffold. 3) Scaffold created and validated by running a small import check. 4) Logged decision to memory bank.
